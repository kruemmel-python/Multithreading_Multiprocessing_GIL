<!DOCTYPE html>

<html lang="de" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Welcome to Multithreading und Multiprocessing’s (GIL) documentation! &#8212; Multithreading Multiprocessing (GIL) 1 Dokumentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=54d918e9"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=70a09b52"></script>
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="Program 1: Multithreading und Multiprocessing" href="program1.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-multithreading-und-multiprocessing-s-gil-documentation">
<h1>Welcome to Multithreading und Multiprocessing’s (GIL) documentation!<a class="headerlink" href="#welcome-to-multithreading-und-multiprocessing-s-gil-documentation" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Inhaltsverzeichnis:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="program1.html">Program 1: Multithreading und Multiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="program2.html">Program 2: Multithreading auf Mehrkernsystemen</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html">Welcome to Multithreading und Multiprocessing’s (GIL) documentation!</a></li>
</ul>
</div>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Link to this heading">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Stichwortverzeichnis</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Modulindex</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Suche</span></a></p></li>
</ul>
</section>
<section id="program-1-multithreading-und-multiprocessing">
<h1>Program 1: Multithreading und Multiprocessing<a class="headerlink" href="#program-1-multithreading-und-multiprocessing" title="Link to this heading">¶</a></h1>
<p>Dies ist die Dokumentation der Datei <cite>Multithreading_Multiprocessing.py</cite>.</p>
<section id="multithreading-und-multiprocessing-beispiel-in-python-3-13">
<span id="module-Multithreading_Multiprocessing"></span><h2>Multithreading und Multiprocessing Beispiel in Python 3.13<a class="headerlink" href="#multithreading-und-multiprocessing-beispiel-in-python-3-13" title="Link to this heading">¶</a></h2>
<p>Dieses Modul zeigt, wie man Multithreading und Multiprocessing in Python 3.13 kombinieren kann.
Es gibt mehrere Prozesse, die jeweils mehrere Threads innerhalb eines Prozesses starten, um Aufgaben parallel auszuführen.</p>
<section id="module">
<h3>Module:<a class="headerlink" href="#module" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><cite>multiprocessing</cite>: Bietet Unterstützung für die parallele Ausführung von Prozessen.</p></li>
<li><p><cite>threading</cite>: Ermöglicht die parallele Ausführung von Threads innerhalb eines Prozesses.</p></li>
</ul>
</section>
<section id="funktionen">
<h3>Funktionen:<a class="headerlink" href="#funktionen" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><cite>thread_task(task_id)</cite>: Führt eine simulierte Aufgabe aus, die durch einen Thread erledigt wird.</p></li>
<li><p><cite>process_task(process_id)</cite>: Erstellt mehrere Threads innerhalb eines Prozesses und führt sie aus.</p></li>
<li><p><cite>main</cite>: Erstellt mehrere Prozesse, die wiederum mehrere Threads enthalten, und synchronisiert deren Ausführung.</p></li>
</ul>
</section>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing.process_task">
<span class="sig-prename descclassname"><span class="pre">Multithreading_Multiprocessing.</span></span><span class="sig-name descname"><span class="pre">process_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process_id</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing.html#process_task"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing.process_task" title="Link to this definition">¶</a></dt>
<dd><p>Erstellt und startet mehrere Threads innerhalb eines Prozesses.</p>
<p>Jeder Prozess startet 3 Threads, die parallel Aufgaben ausführen.</p>
<section id="args">
<h2>Args:<a class="headerlink" href="#args" title="Link to this heading">¶</a></h2>
<p>process_id (int): Die ID des Prozesses, um die Ausgabe zu kennzeichnen.</p>
</section>
<section id="beispiel">
<h2>Beispiel:<a class="headerlink" href="#beispiel" title="Link to this heading">¶</a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">process_task</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Prozess 1 startet.</span>
<span class="go">Thread 0 startet.</span>
<span class="go">Thread 1 startet.</span>
<span class="go">Thread 2 startet.</span>
<span class="go">Thread 0 beendet.</span>
<span class="go">Thread 1 beendet.</span>
<span class="go">Thread 2 beendet.</span>
<span class="go">Prozess 1 beendet.</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing.thread_task">
<span class="sig-prename descclassname"><span class="pre">Multithreading_Multiprocessing.</span></span><span class="sig-name descname"><span class="pre">thread_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task_id</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing.html#thread_task"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing.thread_task" title="Link to this definition">¶</a></dt>
<dd><p>Führt eine Aufgabe in einem separaten Thread aus.</p>
<p>Jeder Thread simuliert eine Aufgabe, indem er für 2 Sekunden schläft, bevor er seine Arbeit beendet.</p>
<section id="id1">
<h2>Args:<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<p>task_id (int): Die ID des Threads, um die Ausgabe zu kennzeichnen.</p>
</section>
<section id="id2">
<h2>Beispiel:<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thread_task</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Thread 1 startet.</span>
<span class="go">(Nach 2 Sekunden)</span>
<span class="go">Thread 1 beendet.</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="program-2-multithreading-auf-mehrkernsystemen">
<h1>Program 2: Multithreading auf Mehrkernsystemen<a class="headerlink" href="#program-2-multithreading-auf-mehrkernsystemen" title="Link to this heading">¶</a></h1>
<p>Dies ist die Dokumentation der Datei <cite>Multithreading_Multiprocessing_Mehrkernsysteme.py</cite>.</p>
<section id="multithreading-und-multiprocessing-mit-separaten-guis-in-python-3-13">
<span id="module-Multithreading_Multiprocessing_Mehrkernsysteme"></span><h2>Multithreading und Multiprocessing mit separaten GUIs in Python 3.13<a class="headerlink" href="#multithreading-und-multiprocessing-mit-separaten-guis-in-python-3-13" title="Link to this heading">¶</a></h2>
<p>Dieses Modul zeigt, wie man Multithreading und Multiprocessing in Python 3.13 verwendet, 
um zwei parallele GUIs zu erstellen, die miteinander über eine geteilte Ressource 
(den Zähler) interagieren. Hierbei laufen die GUIs in separaten Prozessen und verwenden
einen gemeinsam genutzten Zähler über <cite>multiprocessing.Value</cite>.</p>
<section id="fachliche-informationen">
<h3>Fachliche Informationen:<a class="headerlink" href="#fachliche-informationen" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Speicherverwaltung</strong>: Beide GUIs laufen in separaten Prozessen, die jeweils ihren eigenen 
Speicherbereich haben. Der Zähler wird jedoch als <strong>shared memory</strong> (gemeinsamer Speicher) 
über das <cite>multiprocessing.Value</cite>-Objekt implementiert. Dies ermöglicht es den Prozessen,
sicher auf denselben Speicherbereich zuzugreifen. Um Datenkonflikte zu vermeiden, wird 
ein Lock (<cite>counter.get_lock()</cite>) verwendet, um den Zugriff auf den Zähler zu synchronisieren.</p></li>
<li><p><strong>CPU-Nutzung</strong>: Da Prozesse voneinander getrennt sind, können sie auf verschiedenen <strong>CPU-Kernen</strong>
laufen, was eine bessere Nutzung der Ressourcen ermöglicht. Jeder GUI-Prozess läuft unabhängig 
und teilt sich den gemeinsamen Zähler im Shared Memory. Python 3.13 optimiert den Umgang 
mit dem GIL (Global Interpreter Lock), sodass Prozesse effizient parallel arbeiten können.
Innerhalb jedes Prozesses kann zusätzlich <strong>Multithreading</strong> verwendet werden, um die 
Benutzeroberflächen reaktionsfähig zu halten, da sie auf mehrere Aufgaben gleichzeitig reagieren können.</p></li>
<li><p><strong>Verwendung von Prozessen und Threads</strong>: Zwei unabhängige Prozesse, einer für jedes GUI, greifen 
auf denselben Zähler im Shared Memory zu. Die Prozesse laufen parallel und können mehrere Threads 
innerhalb jedes Prozesses verwenden, um GUI-Aktivitäten und Hintergrundaufgaben zu parallelisieren.</p></li>
</ul>
</section>
<section id="id3">
<h3>Module:<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><cite>multiprocessing</cite>: Erstellt separate Prozesse, die auf verschiedenen CPU-Kernen laufen können,
und ermöglicht den Zugriff auf gemeinsam genutzte Ressourcen (wie den Zähler).</p></li>
<li><p><cite>threading</cite>: Führt mehrere Threads innerhalb eines Prozesses aus, um verschiedene GUI-Aufgaben parallel auszuführen.</p></li>
</ul>
</section>
<section id="id4">
<h3>Funktionen:<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><cite>update_counter(increment)</cite>: Erhöht oder verringert den Zähler, der von beiden GUIs geteilt wird. 
Der Zugriff auf den Zähler wird über ein Lock geschützt, um Konflikte zu vermeiden.</p></li>
<li><p><cite>FirstGUI</cite>: Erstellt das erste GUI, mit der Möglichkeit, den Zähler zu erhöhen oder zu verringern. 
Die GUI zeigt den aktuellen Wert des Zählers an und aktualisiert diesen regelmäßig.</p></li>
<li><p><cite>SecondGUI</cite>: Erstellt das zweite GUI, das den Zählerstand anzeigt und den Zähler auf 0 zurücksetzen kann. 
Auch diese GUI aktualisiert den Zählerstand regelmäßig.</p></li>
<li><p><cite>start_first_gui()</cite>: Startet das erste GUI in einem separaten Prozess und verwendet Threads, um die GUI reaktionsfähig zu halten.</p></li>
<li><p><cite>start_second_gui()</cite>: Startet das zweite GUI in einem separaten Prozess und verwendet Threads für die GUI-Verwaltung.</p></li>
<li><p><cite>main</cite>: Startet beide GUIs als separate Prozesse. Jeder Prozess greift auf den gemeinsam genutzten Zähler im Shared Memory zu und aktualisiert den Zähler regelmäßig.</p></li>
</ul>
</section>
<section id="ablauf">
<h3>Ablauf:<a class="headerlink" href="#ablauf" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Das Programm startet zwei unabhängige Prozesse, <cite>process_1</cite> und <cite>process_2</cite>, die jeweils ein GUI darstellen.</p></li>
<li><p>Beide Prozesse greifen über <cite>multiprocessing.Value</cite> auf denselben Zähler im Shared Memory zu.</p></li>
<li><p>Innerhalb jedes Prozesses werden Threads verwendet, um die GUI-Aktivitäten zu handhaben.</p></li>
<li><p>Änderungen am Zähler (Erhöhen, Verringern oder Zurücksetzen) in einem GUI werden sofort im anderen GUI reflektiert, da beide GUIs den Zählerstand regelmäßig aus dem Shared Memory abfragen.</p></li>
</ol>
</section>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Multithreading_Multiprocessing_Mehrkernsysteme.</span></span><span class="sig-name descname"><span class="pre">FirstGUI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">master</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#FirstGUI"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Erstellt das erste GUI, das den gemeinsamen Zähler anzeigen und ändern kann.</p>
<p>Dieses GUI hat zwei Buttons, um den Zähler zu erhöhen oder zu verringern. 
Die Anzeige wird regelmäßig aktualisiert, um den aktuellen Wert des Zählers anzuzeigen, 
der von beiden GUIs geteilt wird.</p>
<section id="speichereffizienz">
<h2>Speichereffizienz:<a class="headerlink" href="#speichereffizienz" title="Link to this heading">¶</a></h2>
<p>Da die GUIs in separaten Prozessen laufen, haben sie voneinander getrennte Speicherbereiche. 
Der Zähler wird jedoch über den <strong>shared memory</strong> (<cite>multiprocessing.Value</cite>) gemeinsam genutzt und 
über ein Lock synchronisiert, um Konflikte zu verhindern.</p>
<dl class="py method">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI.decrement_counter">
<span class="sig-name descname"><span class="pre">decrement_counter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#FirstGUI.decrement_counter"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI.decrement_counter" title="Link to this definition">¶</a></dt>
<dd><p>Verringert den Zähler um 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI.increment_counter">
<span class="sig-name descname"><span class="pre">increment_counter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#FirstGUI.increment_counter"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI.increment_counter" title="Link to this definition">¶</a></dt>
<dd><p>Erhöht den Zähler um 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI.update_display">
<span class="sig-name descname"><span class="pre">update_display</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#FirstGUI.update_display"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.FirstGUI.update_display" title="Link to this definition">¶</a></dt>
<dd><p>Aktualisiert die Zähleranzeige im GUI, um den aktuellen Wert anzuzeigen.</p>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.SecondGUI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Multithreading_Multiprocessing_Mehrkernsysteme.</span></span><span class="sig-name descname"><span class="pre">SecondGUI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">master</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">counter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#SecondGUI"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.SecondGUI" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Erstellt das zweite GUI, das den gemeinsamen Zähler anzeigen und zurücksetzen kann.</p>
<p>Dieses GUI zeigt den aktuellen Zählerstand an und bietet eine Schaltfläche, um 
den Zähler auf 0 zurückzusetzen. Die Anzeige wird regelmäßig aktualisiert.</p>
<section id="prozessorverwaltung">
<h2>Prozessorverwaltung:<a class="headerlink" href="#prozessorverwaltung" title="Link to this heading">¶</a></h2>
<p>Jeder GUI-Prozess läuft auf einem separaten CPU-Kern (falls verfügbar). 
Beide GUIs verwenden den gleichen Zähler im Shared Memory.</p>
<dl class="py method">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.SecondGUI.reset_counter">
<span class="sig-name descname"><span class="pre">reset_counter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#SecondGUI.reset_counter"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.SecondGUI.reset_counter" title="Link to this definition">¶</a></dt>
<dd><p>Setzt den Zähler auf 0 zurück.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.SecondGUI.update_display">
<span class="sig-name descname"><span class="pre">update_display</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#SecondGUI.update_display"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.SecondGUI.update_display" title="Link to this definition">¶</a></dt>
<dd><p>Aktualisiert die Zähleranzeige im GUI, um den aktuellen Wert anzuzeigen.</p>
</dd></dl>

</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.start_first_gui">
<span class="sig-prename descclassname"><span class="pre">Multithreading_Multiprocessing_Mehrkernsysteme.</span></span><span class="sig-name descname"><span class="pre">start_first_gui</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">counter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#start_first_gui"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.start_first_gui" title="Link to this definition">¶</a></dt>
<dd><p>Startet das erste GUI in einem separaten Prozess.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.start_second_gui">
<span class="sig-prename descclassname"><span class="pre">Multithreading_Multiprocessing_Mehrkernsysteme.</span></span><span class="sig-name descname"><span class="pre">start_second_gui</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">counter</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#start_second_gui"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.start_second_gui" title="Link to this definition">¶</a></dt>
<dd><p>Startet das zweite GUI in einem separaten Prozess.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Multithreading_Multiprocessing_Mehrkernsysteme.update_counter">
<span class="sig-prename descclassname"><span class="pre">Multithreading_Multiprocessing_Mehrkernsysteme.</span></span><span class="sig-name descname"><span class="pre">update_counter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">counter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">increment</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Multithreading_Multiprocessing_Mehrkernsysteme.html#update_counter"><span class="viewcode-link"><span class="pre">[Quellcode]</span></span></a><a class="headerlink" href="#Multithreading_Multiprocessing_Mehrkernsysteme.update_counter" title="Link to this definition">¶</a></dt>
<dd><p>Erhöht oder verringert den gemeinsamen Zählerwert sicher.</p>
<p>Der Zugriff auf den Zähler wird über ein Lock synchronisiert, um sicherzustellen,
dass nur ein Prozess gleichzeitig den Wert ändern kann.</p>
<section id="id5">
<h2>Args:<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h2>
<p>counter (multiprocessing.Value): Gemeinsame Zählervariable.
increment (int): Wert, um den der Zähler erhöht oder verringert werden soll.</p>
</section>
<section id="id6">
<h2>Beispiel:<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h2>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">update_counter</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Erhöht den Zähler um 1.</span>
</pre></div>
</div>
</section>
</dd></dl>

</section>
<section id="readme">
<h1>README<a class="headerlink" href="#readme" title="Link to this heading">¶</a></h1>
<p>Dies ist die Dokumentation der Datei <cite>README.md</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Multithreading und Multiprocessing mit Python 3.13

Dieses Projekt zeigt, wie Multithreading und Multiprocessing in Python 3.13 verwendet werden können, um parallele Aufgaben zu verarbeiten. Es werden zwei verschiedene Ansätze zur Parallelisierung in Python demonstriert:

1. **Code 1**: Multithreading und Multiprocessing in einem einfachen Setup ohne GUIs.
2. **Code 2**: Multithreading und Multiprocessing mit zwei parallelen GUIs, die auf eine gemeinsam genutzte Ressource zugreifen.

## Unterschiede zwischen Code 1 und Code 2 im Umgang mit dem Global Interpreter Lock (GIL)

### GIL in Python

Der **Global Interpreter Lock (GIL)** ist ein Mechanismus in der Python-Interpreter-Implementierung (CPython), der verhindert, dass mehrere native Threads gleichzeitig Python-Bytecode ausführen. Der GIL sorgt dafür, dass in einem multithreaded Python-Programm immer nur ein Thread zur gleichen Zeit Python-Code ausführen kann, was die parallele Ausführung auf Mehrkernsystemen einschränkt.

### **Code 1**: Multithreading und Multiprocessing ohne GUIs

In **Code 1** wird Multithreading innerhalb von Prozessen verwendet:

- **Verwendung von Threads und Prozessen**: Es werden zwei **Prozesse** erstellt, die jeweils **mehrere Threads** starten, um Aufgaben parallel auszuführen.
- **GIL-Beschränkungen**: Da Python-Threads denselben Prozess teilen, greift der GIL, was bedeutet, dass nur ein Thread gleichzeitig ausgeführt wird, selbst wenn mehrere CPU-Kerne verfügbar sind.
- **Nachteile bei CPU-gebundenen Aufgaben**: Bei CPU-intensiven Aufgaben kann der GIL die Ausführung verlangsamen, da nur ein Thread zur gleichen Zeit Python-Code ausführen kann. Auf Mehrkernsystemen wird echte Parallelität durch den GIL verhindert.
- **Geeignet für I/O-gebundene Aufgaben**: Für I/O-gebundene Aufgaben, wie Dateizugriffe oder Netzwerkoperationen, kann der GIL freigegeben werden, was die Effizienz von Multithreading erhöht.

### **Code 2**: Multithreading und Multiprocessing mit separaten GUIs

**Code 2** umgeht die GIL-Beschränkungen durch die Verwendung von **Multiprocessing** für die beiden GUIs:

- **Verwendung von Prozessen für GUIs**: In Code 2 werden zwei separate **Prozesse** gestartet, die jeweils ein GUI darstellen. Diese Prozesse laufen unabhängig voneinander und nutzen denselben Zähler, der über **shared memory** (gemeinsamer Speicher) synchronisiert wird.
- **Umgehung des GIL durch Prozesse**: Da jeder Prozess seinen eigenen Python-Interpreter und Speicherbereich hat, wird der GIL **pro Prozess** angewendet. Dies ermöglicht echte Parallelität auf Mehrkernsystemen, da jeder Prozess auf einem separaten CPU-Kern ausgeführt werden kann.
- **Effizienz bei CPU-gebundenen Aufgaben**: Da der GIL nur innerhalb eines Prozesses wirkt, können CPU-intensive Aufgaben auf verschiedene Prozesse aufgeteilt und parallel auf mehreren Kernen ausgeführt werden, ohne durch den GIL gebremst zu werden.
- **GUI-Reaktionsfähigkeit**: Innerhalb jedes Prozesses können weiterhin Threads verwendet werden, um GUI-Aufgaben wie die Verarbeitung von Benutzereingaben auszuführen. Da diese Aufgaben oft I/O-gebunden sind, wird die GIL-Beschränkung innerhalb eines Prozesses kaum spürbar sein.

### Zusammenfassung des Vergleichs

| Aspekt                      | **Code 1: Multithreading &amp; Multiprocessing (ohne GUI)** | **Code 2: Multithreading &amp; Multiprocessing mit GUIs** |
|-----------------------------|----------------------------------------------------------|-------------------------------------------------------|
| **GIL-Beschränkungen**       | Der GIL verhindert echte Parallelität innerhalb eines Prozesses. | Der GIL wird pro Prozess angewendet und behindert daher nicht die Parallelität zwischen Prozessen. |
| **Parallelität**             | Threads innerhalb eines Prozesses sind auf den GIL beschränkt. | Prozesse können auf mehreren CPU-Kernen unabhängig voneinander laufen und echte Parallelität erreichen. |
| **Effizienz bei CPU-Aufgaben**| CPU-intensive Threads werden durch den GIL gebremst. | CPU-intensive Aufgaben können in separaten Prozessen effizient ausgeführt werden. |
| **Speicherverwaltung**       | Threads teilen sich den Speicher im selben Prozess. | Jeder Prozess hat seinen eigenen Speicher. Gemeinsame Ressourcen werden über Shared Memory synchronisiert. |
| **Verwendete Techniken**     | Threads innerhalb von Prozessen für parallele Aufgaben. | Separate Prozesse für jede GUI, die parallel auf mehreren CPU-Kernen laufen können. |

### Wie Sphinx die Dokumentation integriert

Die Sphinx-Dokumentation dieses Projekts zeigt detailliert, wie Multithreading und Multiprocessing in den beiden Codes umgesetzt wird. Die wichtigsten Funktionen und Module sind dokumentiert, um die Implementierung von parallelen Prozessen und Threads verständlich zu machen.

## Installation und Ausführung

1. **Clone das Repository**:
   ```bash
   git clone &lt;repository-url&gt;
   cd &lt;repository-folder&gt;
</pre></div>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">Multithreading Multiprocessing (GIL)</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Inhaltsverzeichnis:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="program1.html">Program 1: Multithreading und Multiprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="program2.html">Program 2: Multithreading auf Mehrkernsystemen</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html">Welcome to Multithreading und Multiprocessing’s (GIL) documentation!</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
      <li>Next: <a href="program1.html" title="nächstes Kapitel">Program 1: Multithreading und Multiprocessing</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Schnellsuche</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Los" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ralf Krümmel.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>